---
marp: true
theme: uncover
style: |
  .columns {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    align-items: center;
    gap: 1rem;
  }
math: mathjax
---
<!-- class: invert -->
<style>
section ul li[data-bespoke-marp-fragment=inactive] {
    visibility: visible;
    opacity: .1;
}
section ul li[data-bespoke-marp-fragment=active] ul li[data-bespoke-marp-fragment=active] {
    visibility: visible;
    opacity: 1;
}
section ul li[data-bespoke-marp-fragment=active] ul li[data-bespoke-marp-fragment=inactive] {
    visibility: visible;
    opacity: .1;
}
section ul li[data-bespoke-marp-fragment=inactive] ul li[data-bespoke-marp-fragment=inactive] {
    visibility: visible;
    opacity: 1;
}
</style>
# Lesson 3

---

## Overview meetings
* ~~Lesson 1: 🤝 Introduction~~
* ~~Lesson 2: 🔢 Guest lecture TNO~~
* Lesson 3: ⏛ Quantum Computing
* Lesson 4: 👨‍💻 Quantum Algoritms
* Lesson 5: 🎮 Games
* Lesson 6: 🕹️ Quantum Games
* 👩‍🏫 Project presentations

---

## Today

* 🔢 Mathematical formalism
* 🔒 Quantum Key Distribution
* ⏛ Quantum circuits
* 🔍 Grover
* 🏋️ Exercise
* 👥 Joint wrap-up

---

## Mathematical Formalism

* Why?
    * 🗣️ Needed to understand videos/literature/documentation about quantum computing
    * 🧠 Insight: vectors give superposition and tensor products entanglement
* As little as possible

---

### Syntax

| 🔢 Matrix notation                              | 👙 Bra-ket notation        |
|------------------------------------------------|---------------------------|
| Vector: $\begin{bmatrix}a\\c\end{bmatrix}$     | Ket: $\ket{0}$            |
| Matrix: $\begin{bmatrix}a&b\\c&d\end{bmatrix}$ | Ket-Bra: $\ket{0}\bra{0}$ |

* State typically $\ket\phi$ of $\ket\psi$. 
* Operator typically capitals: $A$, $B$, etc. 
* Coefficients typically Greek or small: $\alpha$, $a$, $\beta$, $b$ etc. 

---

### Vectors

* $\begin{bmatrix}a\\b\end{bmatrix}=a\begin{bmatrix}1\\0\end{bmatrix}+b\begin{bmatrix}0\\1\end{bmatrix}$, so
    * with probability $|a|^2$ zero, and 
    * with probability $|b|^2$ one
* Superposition if $a\neq 0$ and $b\neq 0$. 
* Every state can be written like this.
* Multiple different *bases* are possible... (more later)
* How do we do arithmetic with vectors?

---

### Complex numbers
Everything you need to know:
* Definition: $i^2=-1$
* Absolute value: $|i|=1$
* Simply do the maths. 

---

### Bloch sphere

![width:12em](Bloch_sphere.svg)

---

### Matrices

![bg](matrix.jpg)

---

#### A matrix as a function

<div class="columns"><div style="text-align: right;">

$\begin{bmatrix}1\\2\end{bmatrix}$

</div><div>

![width:7em](./function.svg)

</div><div style="text-align: left;">

$\begin{bmatrix}1\\0\end{bmatrix}$

</div></div>

---

#### Linearity of matrices
<style scoped>
img {
  vertical-align: middle;
}
</style>

* From now on, write $\left[\begin{smallmatrix}a\\b\end{smallmatrix}\right]$ ![width:2em](./function.svg) $\left[\begin{smallmatrix}c\\d\end{smallmatrix}\right]$ as $A\left[\begin{smallmatrix}a\\b\end{smallmatrix}\right]=\left[\begin{smallmatrix}c\\d\end{smallmatrix}\right]$
* Check the output of *basisvectors*: 
    * $A\left[\begin{smallmatrix}1\\0\end{smallmatrix}\right]=\left[\begin{smallmatrix}-1\\2\end{smallmatrix}\right]$
    * $A\left[\begin{smallmatrix}0\\1\end{smallmatrix}\right]=\left[\begin{smallmatrix}1\\-1\end{smallmatrix}\right]$
* *Linearity* gives: 
    * $A\left[\begin{smallmatrix}1\\2\end{smallmatrix}\right]=A(\left[\begin{smallmatrix}1\\0\end{smallmatrix}\right]+2\left[\begin{smallmatrix}0\\1\end{smallmatrix}\right])=A\left[\begin{smallmatrix}1\\0\end{smallmatrix}\right]+2A\left[\begin{smallmatrix}0\\1\end{smallmatrix}\right]=\left[\begin{smallmatrix}-1\\2\end{smallmatrix}\right]+2\left[\begin{smallmatrix}1\\-1\end{smallmatrix}\right]$ $=\left[\begin{smallmatrix}1\\0\end{smallmatrix}\right]$. 

---

#### Rules

* $\star$ States have norm 1
* Matrices: 
    * have to preserve $\star$, so are *unitary*, so are rotations, so
    * are invertible. 
        * In quantum computing this is called *reversible*. 
        * The *no cloning theorem* follows from this. 

---

#### Arithmetic with matrices

* Addition/subtraction $A\pm B$
* Multiplication
    * Matrix times matrix $AB$
        * Matrix inverse $A^{-1}$ (difficult, don't try)
    * Number times matrix $\alpha B$
* Tensorproducts $A\otimes B$, ...

---

### Tensors

<!-- geen tensorflow -->
* We need more qubits for entanglement
* We look at the joint state space
* In vectors: 
$\left[\begin{smallmatrix}a\\b\end{smallmatrix}\right]\otimes\left[\begin{smallmatrix}c\\d\end{smallmatrix}\right]=\left[\begin{smallmatrix}ac\\bc\\ad\\bd\end{smallmatrix}\right]$
* in kets: 
$$(a\ket{0}+b\ket{1})\otimes(c\ket{0}+d\ket{1})=ac\ket{00}+bc\ket{01}+ad\ket{10}+bd\ket{11}$$
* Not all $\cdots\ket{00}+\cdots\ket{01}+\cdots\ket{10}+\cdots\ket{11}$ we can write as $\cdots\otimes\cdots$ and that is entanglement!
* $\otimes$ also exists for matrices (what about CNOT?)

---

### Bras

* Kets are easy, bras are more difficult
* $\bra{1}=[\begin{smallmatrix}0&1\end{smallmatrix}]$
* One last product: the inner product
* $\ket{1}\bra{1}$ is a matrix, and $\bra{1}\ket{1}$ is a number

---

### 🏋️ Practice

* What is $HH$?
* What is $H\ket{+}$ and what is $H\ket{-}$?
* Why can a gate not have an empty collumn?
* Is entanglement possible without a two-qubit gate?
* What is the CNOT of $\ket{0}$ and $\ket{+}$?
* Why is the CPHASE called like that?
* What is $H\otimes I$? Not that $I$ is the operator that does nothing. 
* Questions about the maths?

---

## Today

* 🔢 ~~Mathematical formalism~~
* 🔒 Quantum Key Distribution
* ⏛ Quantum circuits
* 🔍 Grover
* 🏋️ Exercise
* 👥 Joint wrap-up

---

## 🔒 Quantum key distribution
(We do BB84, but E91 also exists)

---

### Algorithm: quantum + classical
<style scoped>
     table {
  border: 1px solid white;
  font-size: smaller;
  }

  td, th {
    padding: 4pt;
    margin: 0;
  border: 1px solid white;
  }
    </style>

* Quantum, two bases: 

| Measure  | ↙️↗️   | ↙️↗️   | ↙️↗️    | ↙️↗️    |  ⬆️⬇️  | ⬆️⬇️  | ⬆️⬇️ | ⬆️⬇️ |
|-------|------|------|-------|-------|-------|-------|------|------|
| Begin | ↗️    | ↙️    | ⬆️     | ⬇️     | ↗️    | ↙️    | ⬆️   | ⬇️   |
| End  | ↗️    | ↙️    | ↙️❓↗️   | ↙️❓↗️   | ⬆️❓⬇️ | ⬆️❓⬇️ | ⬆️   | ⬇️   |

* Classical, a clever *protocol*.

---

### The quantum part
* The state $\alpha\ket{0}+\beta\ket{1}$ measure in the 0/1 basis: 
    * With probability $|\alpha|^2$ we get $\ket{0}$
    * With probability $|\beta|^2$ we get $\ket{1}$
* The state $\alpha\ket{0}+\beta\ket{1}$ measure in the +/- basis: 
    * First rewrite: 
    $\alpha\ket{0}+\beta\ket{1}=(\alpha+\beta)(\ket{0}+\ket{1})+(\alpha-\beta)(\ket{0}-\ket{1})$
    $=(\alpha+\beta)\ket{+}+(\alpha-\beta)\ket{-}$
        * 🤫 (actually that was the Hadamard)
    * With probability $|\alpha+\beta|^2$ we get $\ket{+}$
    * With probability $|\alpha-\beta|^2$ we get $\ket{-}$

---

### The classical part: privacy check

* 🔒 Measure entangled qubits in random bases
* 🔓 Tell the bases classically: equal bases must give the same measurement results

| 👧    | 👧     |   | 👦     | 👦    |
|-------|--------|---|--------|-------|
| basis | measurement |   | measurement | basis |
| ↙️↗️  | ↗️     |   | ⬇️     | ⬆️⬇️  |
| ⬆️⬇️  | ⬇️     |   | ⬇️     | ⬆️⬇️  |
| ↙️↗️  | ↙️     |   | ↙️     | ↙️↗️  |


---

### The classical part: retrieving the key

* 🎲 Do measurements in random bases
* 🗑️ Throw the measurements away with different bases
* ☑ Choose a number of measurements as a check
    * 🔑 The remaining part is the secret key

---

### 🏋️ Practice

* What happens if 🕵️ evedrops?
* Does the order of measurement of 👧 and 👦 matter?
* With what probability does 🕵️ get caught?
* The state $\ket{0}-\ket{1}$ is measured in the basis $\ket{+i}$/$\ket{-i}$. What are the possible outcomes with corresponding probabilities?

---

## Today

* 🔢 ~~Mathematical formalism~~
* 🔒 ~~Quantum Key Distribution~~
* ⏛ Quantum circuits
* 🔍 Grover
* 🏋️ Exercise
* 👥 Joint wrap-up

---

## Circuits

---

### 🏛️ Classical circuits

![](./gates2.png)

* Bits are copied on the T-junctions
* Binary operations have one output
* Unary operations also exist
* [Overview of operations](https://commons.wikimedia.org/wiki/Logic_gates_unified_symbols)
* Binary addition in the CPU: [voorbeeld](http://cpuville.com/Educational/AND-OR-array-logic.html)

---

### Quantum circuit: example


![](./CircuitExample.png)

---

### Three-qubit gate: Toffoli

![width:5em](./tofolli.png)

* ❗ This is completely unrelated to [qutrits](https://en.wikipedia.org/wiki/Qutrit)!

---

### Ancilla qubits

![width:10em](./cccccnot.png)

* 'Helper' qubits, because everything should be reversible

---

### 🏋️ Practice

* 🔁 Recap: is the teleportation circuit clear?
* Is it possible to make a SWAP 🔀 using only CNOTS?
* If one extra qubit is added to a circuit, how much larger will the matrices become?
* Make a circuit that measures whether a qubit pair is $\ket{00}+\ket{11}$ or $\ket{01}+\ket{10}$. 
* Use the CNOT to make a CPHASE. 

---

## Today

* ~~🔢 Mathematical formalism~~
* ~~🔒 Quantum Key Distribution~~
* ~~⏛ Quantum circuits~~
* 🔍 Grover
* 🏋️ Exercise
* 👥 Joint wrap-up

---

## Grover's algorithm

![width:5em](./pngwing.com.png)

---

### 🔍 Searching

<style scoped>
    code {
        font-size: 70%;
    }
</style>

![](./groveralgowhite.png)

* How fast can we do this classically? $\mathcal{O}(n)$
    * `for (int i=0;i<n;i++) if (succes(a[i])) { found(); break; }`
* In quantum we can do a lot in 'parallel'. 

---

### Step by step

The start and end is similar to other quantum algorithms: 

* First make a mega-superposition using Hadamards
* Then do a number ($\approx\sqrt{N}$) of iterations:
    * the oracle
    * a diffusion operator
* Measure everything at the end

---

### The oracle 🔮

* Fancy name for the `success()` method
* A black-box (are we looking for solutions to sudoku's?)
* Reversible? Two possible implementations: 
    * XOR the answer with an extra helper qubit
    * Encode the answer in the phase $\pm$

---

### Reflect about the mean

On the white-board 👨‍🏫

---

## Today

* ~~🔢 Mathematical formalism~~
* ~~🔒 Quantum Key Distribution~~
* ~~⏛ Quantum circuits~~
* ~~🔍 Grover~~
* 🏋️ Exercise
* 👥 Joint wrap-up

---

## 🏋️ Exercise
* Alone or in couples:
    * ❓ Prepare and formulate some interesting quantions about today's lesson. 
    * 📝 Implement Grover's algorithm in Quantum Inspire. More explanation: [Qiskit's explanation of Grover](https://learn.qiskit.org/course/ch-algorithms/grovers-algorithm)
* For at home: 
    * 🖥️ Programming exercise: make your own quantum computer simulator
    * 👥 Form groups
* Feedback lesson last week?
    *  ❓ Other feedback very welcome!

---

## Joint wrap-up
* What have we learned?
* Discuss questions
* What awaits us?

---

<!--
color: black
-->
### We do this together

![bg grayscale:1 blur:5px](https://cdn2.psychologytoday.com/assets/styles/manual_crop_1_91_1_1528x800/public/2020-08/shutterstock_1731284125_0.jpg?itok=89UrdUt_)

* Ask for help if it doesn't work
* Also help unsolicited
* Get out what you want to get out of it
* Community